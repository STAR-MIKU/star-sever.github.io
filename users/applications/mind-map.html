<!DOCTYPE html>
<html>
<head>
  <title>思维导图生成器</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      padding: 20px;
      background: #f9f9f9;
      display: grid;
      grid-template-columns: 250px 1fr;
      gap: 20px;
      height: 100vh;
      box-sizing: border-box;
    }
    .sidebar {
      background: white;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
    }
    .canvas-container {
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      position: relative;
    }
    #mindMapCanvas {
      width: 100%;
      height: 100%;
      cursor: grab;
    }
    #mindMapCanvas.grabbing {
      cursor: grabbing;
    }
    .controls {
      margin-bottom: 20px;
    }
    .control-group {
      margin-bottom: 15px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      font-size: 14px;
    }
    input, select, textarea, button {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
      font-family: inherit;
      font-size: 14px;
    }
    button {
      background: #3b82f6;
      color: white;
      border: none;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover {
      background: #2563eb;
    }
    .node-properties {
      margin-top: auto;
      padding-top: 15px;
      border-top: 1px solid #eee;
    }
    .node-color {
      display: flex;
      gap: 5px;
      margin-top: 5px;
    }
    .color-option {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
    }
    .color-option.selected {
      border-color: #3b82f6;
    }
    .export-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .export-controls button {
      flex: 1;
    }
    .help-text {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <div class="controls">
      <h3>创建节点</h3>
      <div class="control-group">
        <label for="nodeText">节点文本</label>
        <input type="text" id="nodeText" placeholder="输入节点内容">
      </div>
      <button id="addRoot">添加根节点</button>
      <p class="help-text">根节点是思维导图的起点</p>
      <button id="addChild" disabled>添加子节点</button>
      <p class="help-text">需先选中一个现有节点</p>
      <button id="deleteNode" disabled>删除选中节点</button>
    </div>

    <div class="node-properties">
      <h3>节点属性</h3>
      <div class="control-group">
        <label>节点颜色</label>
        <div class="node-color">
          <div class="color-option selected" style="background: #4f46e5;" data-color="#4f46e5"></div>
          <div class="color-option" style="background: #10b981;" data-color="#10b981"></div>
          <div class="color-option" style="background: #ef4444;" data-color="#ef4444"></div>
          <div class="color-option" style="background: #f59e0b;" data-color="#f59e0b"></div>
          <div class="color-option" style="background: #6366f1;" data-color="#6366f1"></div>
        </div>
      </div>
      <div class="export-controls">
        <button id="saveMap">保存导图</button>
        <button id="exportImage">导出图片</button>
      </div>
      <button id="clearMap" style="background: #ef4444; margin-top: 10px;">清空导图</button>
    </div>
  </div>

  <div class="canvas-container">
    <canvas id="mindMapCanvas"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('mindMapCanvas');
    const ctx = canvas.getContext('2d');
    let nodes = [];
    let connections = [];
    let selectedNode = null;
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };
    let canvasOffset = { x: 0, y: 0 };
    let startPan = { x: 0, y: 0 };
    let isPanning = false;
    let nextNodeId = 1;

    // 设置Canvas尺寸
    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      render();
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // 节点类
    class Node {
      constructor(id, text, x, y, color = '#4f46e5') {
        this.id = id;
        this.text = text;
        this.x = x;
        this.y = y;
        this.width = 120;
        this.height = 50;
        this.color = color;
        this.parentId = null;
      }

      // 检查点是否在节点内
      containsPoint(x, y) {
        return x >= this.x - this.width/2 &&
               x <= this.x + this.width/2 &&
               y >= this.y - this.height/2 &&
               y <= this.y + this.height/2;
      }

      // 绘制节点
      draw() {
        // 绘制节点背景
        ctx.beginPath();
        ctx.roundRect(
          this.x - this.width/2,
          this.y - this.height/2,
          this.width,
          this.height,
          8
        );
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // 绘制节点文本
        ctx.fillStyle = 'white';
        ctx.font = '14px Segoe UI, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.text, this.x, this.y);

        // 绘制选中状态
        if (this === selectedNode) {
          ctx.beginPath();
          ctx.roundRect(
            this.x - this.width/2 - 5,
            this.y - this.height/2 - 5,
            this.width + 10,
            this.height + 10,
            10
          );
          ctx.strokeStyle = '#3b82f6';
          ctx.lineWidth = 3;
          ctx.setLineDash([5, 3]);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }
    }

    // 连接线类
    class Connection {
      constructor(fromNodeId, toNodeId) {
        this.fromNodeId = fromNodeId;
        this.toNodeId = toNodeId;
      }

      // 绘制连接线
      draw() {
        const fromNode = nodes.find(n => n.id === this.fromNodeId);
        const toNode = nodes.find(n => n.id === this.toNodeId);
        if (!fromNode || !toNode) return;

        // 计算连接点（节点边缘）
        const dx = toNode.x - fromNode.x;
        const dy = toNode.y - fromNode.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        const fromX = fromNode.x + (dx / distance) * (fromNode.width / 2);
        const fromY = fromNode.y + (dy / distance) * (fromNode.height / 2);
        const toX = toNode.x - (dx / distance) * (toNode.width / 2);
        const toY = toNode.y - (dy / distance) * (toNode.height / 2);

        // 绘制连接线
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        // 绘制曲线
        const controlX = (fromX + toX) / 2;
        const controlY = (fromY + toY) / 2 - 30;
        ctx.quadraticCurveTo(controlX, controlY, toX, toY);
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 2;
        ctx.stroke();

        // 绘制箭头
        const arrowSize = 8;
        const angle = Math.atan2(toY - controlY, toX - controlX);
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(
          toX - arrowSize * Math.cos(angle - Math.PI / 6),
          toY - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          toX - arrowSize * Math.cos(angle + Math.PI / 6),
          toY - arrowSize * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fillStyle = '#ccc';
        ctx.fill();
      }
    }

    // 渲染所有元素
    function render() {
      // 清空画布
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 保存当前状态并应用偏移
      ctx.save();
      ctx.translate(canvasOffset.x, canvasOffset.y);
      
      // 绘制连接线（先于节点绘制）
      connections.forEach(conn => conn.draw());
      
      // 绘制节点
      nodes.forEach(node => node.draw());
      
      ctx.restore();
    }

    // 添加根节点
    document.getElementById('addRoot').addEventListener('click', () => {
      const text = document.getElementById('nodeText').value || '根节点';
      if (nodes.length === 0) {
        // 添加根节点到中心
        const node = new Node(
          nextNodeId++,
          text,
          canvas.width / 2,
          canvas.height / 2
        );
        nodes.push(node);
        selectNode(node);
        document.getElementById('nodeText').value = '';
        render();
      } else {
        alert('只能有一个根节点');
      }
    });

    // 添加子节点
    document.getElementById('addChild').addEventListener('click', () => {
      if (!selectedNode) return;
      
      const text = document.getElementById('nodeText').value || '子节点';
      
      // 计算子节点位置（围绕父节点分布）
      const children = nodes.filter(n => n.parentId === selectedNode.id);
      const angle = (children.length * 60) * (Math.PI / 180);
      const distance = 200;
      
      const x = selectedNode.x + Math.cos(angle) * distance;
      const y = selectedNode.y + Math.sin(angle) * distance;
      
      // 创建子节点
      const childNode = new Node(nextNodeId++, text, x, y);
      childNode.parentId = selectedNode.id;
      nodes.push(childNode);
      
      // 创建连接线
      connections.push(new Connection(selectedNode.id, childNode.id));
      
      selectNode(childNode);
      document.getElementById('nodeText').value = '';
      render();
    });

    // 删除节点
    document.getElementById('deleteNode').addEventListener('click', () => {
      if (!selectedNode) return;
      
      // 递归删除所有子节点
      function deleteNodeAndChildren(nodeId) {
        // 删除子节点
        const children = nodes.filter(n => n.parentId === nodeId);
        children.forEach(child => deleteNodeAndChildren(child.id));
        
        // 删除节点本身
        nodes = nodes.filter(n => n.id !== nodeId);
        
        // 删除相关连接线
        connections = connections.filter(
          conn => conn.fromNodeId !== nodeId && conn.toNodeId !== nodeId
        );
      }
      
      deleteNodeAndChildren(selectedNode.id);
      selectedNode = null;
      updateNodePropertiesUI();
      render();
    });

    // 选择节点
    function selectNode(node) {
      selectedNode = node;
      document.getElementById('nodeText').value = node.text;
      document.getElementById('addChild').disabled = false;
      document.getElementById('deleteNode').disabled = false;
      
      // 更新颜色选择
      document.querySelectorAll('.color-option').forEach(option => {
        option.classList.toggle('selected', option.dataset.color === node.color);
      });
    }

    // 更新节点属性UI状态
    function updateNodePropertiesUI() {
      const hasSelection = !!selectedNode;
      document.getElementById('addChild').disabled = !hasSelection;
      document.getElementById('deleteNode').disabled = !hasSelection;
      document.getElementById('nodeText').value = hasSelection ? selectedNode.text : '';
    }

    // 颜色选择
    document.querySelectorAll('.color-option').forEach(option => {
      option.addEventListener('click', () => {
        if (!selectedNode) return;
        
        document.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        selectedNode.color = option.dataset.color;
        render();
      });
    });

    // 节点文本编辑
    document.getElementById('nodeText').addEventListener('input', () => {
      if (selectedNode) {
        selectedNode.text = document.getElementById('nodeText').value;
        render();
      }
    });

    // 保存思维导图
    document.getElementById('saveMap').addEventListener('click', () => {
      const mapData = {
        nodes: nodes,
        connections: connections,
        nextNodeId: nextNodeId
      };
      localStorage.setItem('mindMapData', JSON.stringify(mapData));
      alert('思维导图已保存！');
    });

    // 导出为图片
    document.getElementById('exportImage').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'mind-map.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    // 清空思维导图
    document.getElementById('clearMap').addEventListener('click', () => {
      if (confirm('确定要清空当前思维导图吗？')) {
        nodes = [];
        connections = [];
        selectedNode = null;
        nextNodeId = 1;
        updateNodePropertiesUI();
        render();
      }
    });

    // 加载保存的思维导图
    function loadSavedMap() {
      const savedData = localStorage.getItem('mindMapData');
      if (savedData) {
        const mapData = JSON.parse(savedData);
        nodes = mapData.nodes.map(n => {
          const node = new Node(n.id, n.text, n.x, n.y, n.color);
          node.parentId = n.parentId;
          return node;
        });
        connections = mapData.connections.map(c => 
          new Connection(c.fromNodeId, c.toNodeId)
        );
        nextNodeId = mapData.nextNodeId;
        render();
      }
    }

    // 画布交互 - 鼠标按下
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // 转换为画布坐标系（考虑偏移）
      const canvasX = mouseX - canvasOffset.x;
      const canvasY = mouseY - canvasOffset.y;
      
      // 检查是否点击了节点
      const clickedNode = nodes.find(node => node.containsPoint(canvasX, canvasY));
      
      if (clickedNode) {
        // 选中节点并准备拖动
        selectNode(clickedNode);
        dragOffset.x = canvasX - clickedNode.x;
        dragOffset.y = canvasY - clickedNode.y;
        isDragging = true;
        canvas.classList.add('grabbing');
      } else {
        // 准备平移画布
        isPanning = true;
        startPan.x = mouseX;
        startPan.y = mouseY;
        selectedNode = null;
        updateNodePropertiesUI();
        canvas.classList.add('grabbing');
      }
      
      render();
    });

    // 画布交互 - 鼠标移动
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      if (isDragging && selectedNode) {
        // 拖动节点
        selectedNode.x = (mouseX - canvasOffset.x) - dragOffset.x;
        selectedNode.y = (mouseY - canvasOffset.y) - dragOffset.y;
        render();
      } else if (isPanning) {
        // 平移画布
        canvasOffset.x += mouseX - startPan.x;
        canvasOffset.y += mouseY - startPan.y;
        startPan.x = mouseX;
        startPan.y = mouseY;
        render();
      }
    });

    // 画布交互 - 鼠标释放
    window.addEventListener('mouseup', () => {
      isDragging = false;
      isPanning = false;
      canvas.classList.remove('grabbing');
    });

    // 初始化
    loadSavedMap();
  </script>
</body>
</html>
